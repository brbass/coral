#include <chrono>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>
#include <vector>

#include "Check.hh"
#include "Linear_Algebra.hh"
#include "Random_Number_Generator.hh"
#include "Timer.hh"

using namespace std;

int main(int argc, char* argv[])
{
    // parse input

    if (argc < 2)
    {
        cerr << "usage: matrix_solution [number_of_elements print_results=false print_debug=false]" << endl;
        return 1;
    }
    
    unsigned number_of_elements = 2;
    bool print_results = false;
    bool print_debug = false;
    bool print_timing = true;

    for (int i=1; i<argc)
    {
        switch(i)
        {
        case 1:
            number_of_elements = atoi(argv[1]);
            return;
        case 2:
            print_results = atoi(argv[2]);
            return;
        case 3:
            print_debug = atoi(argv[3]);
            return;
        }
    }

    // initialize data

    Random_Number_Generator random(0, 1);
    
    vector<double> mat(random.random_double_vector(number_of_elements*number_of_elements));
    vector<double> lhs(random.random_double_vector(number_of_elements));
    
    Linear_Algebra solver(number_of_elements);
    vector<double> rhs(number_of_elements, 0);
    
    solver.multiply(mat, lhs, rhs);
    
    enum Methods
    {
        AMESOS,
        AZTEC,
        BOOST,
        EPETRA,
        GSL
    };
    
    vector<Methods> methods = {AMESOS, AZTEC, EPETRA, GSL};
    unsigned num_methods = methods.size();
    
    vector<string> method_descriptions(num_methods);
    vector<double> time(num_methods, 0);
    vector<double> error(num_methods, 0);
    vector<vector<double>> lhs_store;
    
    // solve problems

    timer Timer;

    for (unsigned i=0; i<num_methods; ++i)
    {
        vector<double> mat_temp(mat);
        vector<double> rhs_temp(mat);
        vector<double> lhs_temp(number_of_elements, 0);
        
        timer.start();

        switch(methods[i]):
        {
        case AMESOS:
            amesos_solve(mat_temp, lhs_temp, rhs_temp);
            method_description[i] = "Amesos";
            return;
        case AZTEC:
            aztec_solve(mat_temp, lhs_temp, rhs_temp);
            method_description[i] = "Aztec";
            return;
        case BOOST:
            boost_solve(mat_temp, lhs_temp, rhs_temp);
            method_description[i] = "Boost";
            return;
        case EPETRA:
            epetra_solve(mat_temp, lhs_temp, rhs_temp);
            method_description[i] = "Epetra";
            return;
        case GSL:
            gsl_solve(mat_temp, lhs_temp, rhs_temp);
            method_description[i] = "GSL";
            return;
        }
        
        timer.stop();
        time[i] = timer.time();

        double sum = 0;
        for (unsigned j=0; j<number_of_elements; ++j)
        {
            sum += pow(rhs_temp[j] - rhs[j], 2);
        }
        error[i] = sum / number_of_elements;
        
        if (print_results)
        {
            lhs_store.push_back(lhs_temp);
        }
    }

    // print results

    unsigned w = 16;
    
    if (print_timing)
    {
        cout << setw(w) << "Method";
        cout << setw(w) << "Timing";
        cout << setw(w) << "Mean Sq. Error";
        cout << endl;

        for (unsigned i=0; i<num_methods; ++i)
        {
            cout << setw(w) << method_description[i];
            cout << setw(w) << time[i];
            cout << setw(w) << error[i];
            cout << endl;
        }
    }
}
